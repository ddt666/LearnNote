# 一、最简单用法



```python
from flask import Flask

# 实例化Flask对象
app = Flask(__name__)

# 路由
# 装饰器的作用是将路由映射到视图函数index
@app.route('/')
def index():
    return "hello world"

# Flask应用程序实例的run方法启动WEB服务器
app.run()
```



# 二、Flask创建app对象

## 1.  初始化参数 

```python
 app=Flask(__name__,static_folder="static",...)
    
0.import_name: 导入路径（寻找静态目录与模板目录位置的参数）
    __name__，表示当前的模块名字，
    flask以这个模块所在的目录为总目录，
    默认这个目录中的static为静态目录，templates为模板目录
    
1.template_folder="temp" 默认模板路径 templates

2.static_folder="static", 默认静态文件路径 static

3.static_url_path="/static" 访问静态文件路由地址 默认是"/"+static_folder

# 以下了解：
4.static_host=None 指定静态文件服务器地址
5.host_matching = False,  # 如果不是特别需要的话,慎用,否则所有的route 都需要host=""的参数
6.subdomain_matching = False,  # 理论上来说是用来限制SERVER_NAME子域名的,但是目前还没有感觉出来区别在哪里
7.instance_path = None,  # 指向另一个Flask实例的路径
8.instance_relative_config = False  # 是否加载另一个实例的配置
9.root_path = None  # 主模块所在的目录的绝对路径,默认项目目录
```

## 2. 配置参数

```python
# config.cfg
DEBUG=True
```

```python
# app.py

from flask import Flask


app = Flask(__name__)

# 配置参数的使用方式
# 方式1.使用配置文件--start--
app.config.from_pyfile(“config.cfg”)
# 方式1.使用配置文件--end--

#方式二、使用对象配置参数---start---
class Config(object):
	DEBUG = True	
    MA = "liang" # 自定义配置参数
    
app.config.from_object(Config)

#方式二、使用对象配置参数---end---

# 方式三、直接操作config的字典对象---start---
app.config["DEBUG"] = True
# 方式三、直接操作config的字典对象---end---


@app.route('/')
def index():
    # 获取配置参数
    app.config.get("MA") # 方式一：直接从全局对象app的config字典中取值
    current_app.config.get("MA") # 方式二：从全局对象app的代理人current_app中config字典中取值
    
    return "hello world"

app.run()
```





### 2.1 配置方式

- 配置参数单独放到一个文件config.cfg
- 从对象的方式导入，定义一个类，类也是一个对象
- 直接操作config的字典对象

### 2.2 在视图读取配置参数

- `app.config.get()` 

- `current_app.config.get()`

### 2.3 app的配置参数解析

```python
{
    'DEBUG': False,  # 是否开启Debug模式,代码只要发生改动,自动重启Flask程序(app.run)
    'TESTING': False,  # 是否开启测试模式
    'PROPAGATE_EXCEPTIONS': None,  # 异常传播(是否在控制台打印LOG) 当Debug或者testing开启后,自动为True
    'PRESERVE_CONTEXT_ON_EXCEPTION': None,  # 一两句话说不清楚,一般不用它
    'SECRET_KEY': None,  # 之前遇到过,在启用Session的时候,一定要有它
    'PERMANENT_SESSION_LIFETIME': 31,  # days , Session的生命周期(天)默认31天
    'USE_X_SENDFILE': False,  # 是否弃用 x_sendfile
    'LOGGER_NAME': None,  # 日志记录器的名称
    'LOGGER_HANDLER_POLICY': 'always',
    'SERVER_NAME': None,  # 服务访问域名
    'APPLICATION_ROOT': None,  # 项目的完整路径
    'SESSION_COOKIE_NAME': 'session',  # 在cookies中存放session加密字符串的名字
    'SESSION_COOKIE_DOMAIN': None,  # 在哪个域名下会产生session记录在cookies中
    'SESSION_COOKIE_PATH': None,  # cookies的路径
    'SESSION_COOKIE_HTTPONLY': True,  # 控制 cookie 是否应被设置 httponly 的标志，
    'SESSION_COOKIE_SECURE': False,  # 控制 cookie 是否应被设置安全标志
    'SESSION_REFRESH_EACH_REQUEST': True,  # 这个标志控制永久会话如何刷新
    'MAX_CONTENT_LENGTH': None,  # 如果设置为字节数， Flask 会拒绝内容长度大于此值的请求进入，并返回一个 413 状态码
    'SEND_FILE_MAX_AGE_DEFAULT': 12,  # hours 默认缓存控制的最大期限
    'TRAP_BAD_REQUEST_ERRORS': False,
    # 如果这个值被设置为 True ，Flask不会执行 HTTP 异常的错误处理，而是像对待其它异常一样，
    # 通过异常栈让它冒泡地抛出。这对于需要找出 HTTP 异常源头的可怕调试情形是有用的。
    'TRAP_HTTP_EXCEPTIONS': False,
    # Werkzeug 处理请求中的特定数据的内部数据结构会抛出同样也是“错误的请求”异常的特殊的 key errors 。
    # 同样地，为了保持一致，许多操作可以显式地抛出 BadRequest 异常。
    # 因为在调试中，你希望准确地找出异常的原因，这个设置用于在这些情形下调试。
    # 如果这个值被设置为 True ，你只会得到常规的回溯。
    'EXPLAIN_TEMPLATE_LOADING': False,
    'PREFERRED_URL_SCHEME': 'http',  # 生成URL的时候如果没有可用的 URL 模式话将使用这个值
    'JSON_AS_ASCII': True,
    # 默认情况下 Flask 使用 ascii 编码来序列化对象。如果这个值被设置为 False ，
    # Flask不会将其编码为 ASCII，并且按原样输出，返回它的 unicode 字符串。
    # 比如 jsonfiy 会自动地采用 utf-8 来编码它然后才进行传输。
    'JSON_SORT_KEYS': True,
    #默认情况下 Flask 按照 JSON 对象的键的顺序来序来序列化它。
    # 这样做是为了确保键的顺序不会受到字典的哈希种子的影响，从而返回的值每次都是一致的，不会造成无用的额外 HTTP 缓存。
    # 你可以通过修改这个配置的值来覆盖默认的操作。但这是不被推荐的做法因为这个默认的行为可能会给你在性能的代价上带来改善。
    'JSONIFY_PRETTYPRINT_REGULAR': True,
    'JSONIFY_MIMETYPE': 'application/json',
    'TEMPLATES_AUTO_RELOAD': None,
}
```



## 3. app.run的启动参数

```python

# app.run() # 默认
app.run(host=”0.0.0.0”, port=5000,debug=True)
```





# 三、 路由

## 1. 查看整个flask中的路由信息

```python
from flask import Flask

app = Flask(__name__)
app.config["DEBUG"] = True


@app.route('/')
def index():
    return "hello world"


if __name__ == '__main__':
    # 通过url_map可以查看整个flask中的路由信息
    print(app.url_map)
    app.run()

```

**结果输出：**

```python
Map([<Rule '/' (OPTIONS, HEAD, GET) -> index>,
 <Rule '/static/<filename>' (OPTIONS, HEAD, GET) -> static>])
```

## 2. 路由装饰器@app.route()

### 2.1 利用methods限制访问方式

```python
@app.route("/",methods=["GET","POST"])
def index(): # 视图函数
	return "hello,world!"
```

### 2.2 @app.route(...)中参数含义

```python
# flask中的路由参数：
    0.rule: "/",通过该路径访问该视图函数
	1.endpoint 反向生成url地址标志 默认视图函数名 url_for
	2.methods 视图函数允许的请求方式,["GET","POST"]
	6."/index/<page>" 动态路由路由参数
		def index(page)
		
	3.defaults={"nid":"123456"} 默认参数
	4.strict_slashes=True 是否严格遵循路由地址
	5.redirect_to="/login" 永久重定向 301
```



### 2.3 同一路由装饰多个视图函数

- 如果路径、请求方法完全一样，会按照app.url_map中顺序进行访问，哪个视图函数在前面就访问哪个
- 如果路径一样，访问方法不一样，就会依据路径和请求方法对视图函数进行匹配

```python
from flask import Flask

app = Flask(__name__)
app.config["DEBUG"] = True


@app.route('/')
def index():
    return "hello world"


# 同一路由装饰多个视图函数
@app.route("/hello", methods=["POST"])
def hello():
    return "hello1"


@app.route("/hello", methods=["GET"])
def hello2():
    return "hello2"

# 同一视图多个路由装饰器
@app.route("/h1")
@app.route("/h2")
def hi():
    return "hi page"

if __name__ == '__main__':
    # 通过url_map可以查看整个flask中的路由信息
    print(app.url_map)
    app.run()
```



### 2.4 同一视图多个路由装饰器

- 通过不同路径都能访问到同一视图函数

## 3. 使用url_for进行反解析 类似Django中的reverse

- 通过视图函数的名字找到视图函数对应的url路径

```python
from flask import Flask, redirect, url_for

app = Flask(__name__)
app.config["DEBUG"] = True


@app.route('/')
def index():
    return "hello world"


@app.route("login")
def login():
    # 使用url_for函数，通过视图函数的名字找到视图函数对应的url路径
    return redirect(url_for(index))


if __name__ == '__main__':
    app.run()

```

## 4. 动态路由

### 4.1 转换器`<int:id>`

```python
# 路由传递的参数默认当做string处理，这里指定int，尖括号中冒号后面的内容是动态的
@app.route('/user/<int:id>')
def hello_itcast(id):
    return 'hello itcast %d' %id

```



![image-20200807183144894](assets/image-20200807183144894.png)

### 4.2 自定义转换器

```python
from flask import Flask
from werkzeug.routing import BaseConverter

class Regex_url(BaseConverter):
    def __init__(self,url_map,*args):
        super(Regex_url,self).__init__(url_map)
        self.regex = args[0]

app = Flask(__name__)
app.url_map.converters['re'] = Regex_url

@app.route('/user/<re("[a-z]{3}"):id>')
def hello_itcast(id):
    return 'hello %s' %id

```

