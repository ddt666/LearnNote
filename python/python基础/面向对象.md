# 面向对象基础语法

###  1. 技巧

- 利用好 `dir()` 函数，传入 **标识符** / **数据**，可以查看对象内的 **所有属性及方法**

- 使用 `print` 输出 **对象变量**，默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址**（**十六进制表示**）

### 2. 类内置方法

```python
class Foo(object):
    # 插槽 只允许该类只能有哪些属性
    __slots__ = ("__storage__", "__ident_func__")
    # 当调用__init__方法之前时，该方法会被调用
    def __new__(cls):
        print(cls)
        return super().__new__(cls)

    # 当对象初始化时，该方法会被调用
    def __init__(self):
        self.name = "haha"
        
        # 给当前类设定一个属性
        object.__setattr__(self, "__storage__", {})
        
   
    
    
    # 当对象加括号 foo() 时，该方法会被调用
    def __call__(self, *args, **kwargs):
        print("对象加()执行我")

    # 当对象设置属性或者方法时，该方法会被调用
    def __setattr__(self, key, value):
        pass

    # 当对象设置元素时时，该方法会被调用
    def __setitem__(self, key, value):
        pass

    # 当调用的属性或者方法不存在时，该方法会被调用
    def __getattr__(self, item):
        print("没有这个属性")

    # 当print(foo)时，该方法会被调用
    def __str__(self):
        return "fooooooo"
    
	# 对象在内存中销毁前，会被自动调用
    def __del__(self):
        pass


if __name__ == '__main__':
    foo = Foo()  # 执行__int__()

    foo()  # 执行 foo.__call__()

    foo.age = 1  # 执行foo.__setattr__方法

    foo["sex"] = "male"  # 执行foo.__setitem__方法

    a = foo.x  # 调用foo.__getattr__方法

    print(foo)

    
```



### 3. 方法中的 `self` 参数

> *由* **哪一个对象** *调用的方法，方法内的* `self` *就是* **哪一个对象的引用**

- 在类封装的方法内部，`self` 就表示 **当前调用方法的对象自己**
- **调用方法时**，程序员不需要传递 `self` 参数
- 在方法内部
  - 可以通过 `self.` **访问对象的属性**
  - 也可以通过 `self.` **调用其他的对象方法**

### 4. 增加属性

> 不推荐在类的外部给对象增加属性，应该 **封装在类的内部**

#### 4.1 初始化方法添加属性

> `__init__` *方法是* **专门** *用来定义一个类* **具有哪些属性的方法**

```python
class Cat:

    def __init__(self, name):
        print("初始化方法 %s" % name)
        self.name = name
    ...
    
tom = Cat("Tom")
...

lazy_cat = Cat("大懒猫")
...
```

