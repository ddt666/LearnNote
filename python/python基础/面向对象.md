# 面向对象基础语法

## **面向对象三大特性**

1. **封装** 根据 **职责** 将 **属性** 和 **方法** **封装** 到一个抽象的 **类** 中
2. **继承** **实现代码的重用**，相同的代码不需要重复的编写
3. **多态** 不同的对象调用相同的方法，产生不同的执行结果，**增加代码的灵活度**



###  1. 技巧

- 利用好 `dir()` 函数，传入 **标识符** / **数据**，可以查看对象内的 **所有属性及方法**

- 使用 `print` 输出 **对象变量**，默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址**（**十六进制表示**）

### 2. 类内置方法

```python
class Foo(object):
    # 插槽 只允许该类只能有哪些属性
    __slots__ = ("__storage__", "__ident_func__")
    # 当调用__init__方法之前时，该方法会被调用
    def __new__(cls):
        print(cls)
        return super().__new__(cls)

    # 当对象初始化时，该方法会被调用
    def __init__(self):
        self.name = "haha"
        
        # 给当前类设定一个属性
        object.__setattr__(self, "__storage__", {})
        
   
    
    
    # 当对象加括号 foo() 时，该方法会被调用
    def __call__(self, *args, **kwargs):
        print("对象加()执行我")

    # 当对象设置属性或者方法时，该方法会被调用
    def __setattr__(self, key, value):
        pass

    # 当对象设置元素时时，该方法会被调用
    def __setitem__(self, key, value):
        pass

    # 当调用的属性或者方法不存在时，该方法会被调用
    def __getattr__(self, item):
        print("没有这个属性")

    # 当print(foo)时，该方法会被调用
    def __str__(self):
        return "fooooooo"
    
	# 对象在内存中销毁前，会被自动调用
    def __del__(self):
        pass


if __name__ == '__main__':
    foo = Foo()  # 执行__int__()

    foo()  # 执行 foo.__call__()

    foo.age = 1  # 执行foo.__setattr__方法

    foo["sex"] = "male"  # 执行foo.__setitem__方法

    a = foo.x  # 调用foo.__getattr__方法

    print(foo)

    
```



### 3. 方法中的 `self` 参数

> *由* **哪一个对象** *调用的方法，方法内的* `self` *就是* **哪一个对象的引用**

- 在类封装的方法内部，`self` 就表示 **当前调用方法的对象自己**
- **调用方法时**，程序员不需要传递 `self` 参数
- 在方法内部
  - 可以通过 `self.` **访问对象的属性**
  - 也可以通过 `self.` **调用其他的对象方法**

### **4. 增加属性**

> 不推荐在类的外部给对象增加属性，应该 **封装在类的内部**

#### 4.1 初始化方法添加属性

> `__init__` *方法是* **专门** *用来定义一个类* **具有哪些属性的方法**

```python
class Cat:

    def __init__(self, name):
        print("初始化方法 %s" % name)
        self.name = name
    ...
    
tom = Cat("Tom")
...

lazy_cat = Cat("大懒猫")
...
```



### **5. 类的生命周期**

- 一个对象从调用 `类名()` 创建，生命周期开始
- 一个对象的 `__del__` 方法一旦被调用，生命周期结束
- 在对象的生命周期内，可以访问对象属性，或者让对象调用方法

### 6. 身份运算符

> 身份运算符用于 **比较** 两个对象的 **内存地址** 是否一致 —— **是否是对同一个对象的引用**

- 在 `Python` 中针对 `None` 比较时，建议使用 `is` 判断

| 运算符 | 描述                                      | 实例                            |
| :----- | :---------------------------------------- | :------------------------------ |
| is     | is 是判断两个标识符是不是引用同一个对象   | x is y，类似 id(x) == id(y)     |
| is not | is not 是判断两个标识符是不是引用不同对象 | x is not y，类似 id(a) != id(b) |

#### is 与 == 区别：

`is` 用于判断 **两个变量 引用对象是否为同一个** 
`==` 用于判断 **引用变量的值** 是否相等

```python
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> b is a 
False
>>> b == a
True
```

### 7. 私有属性和私有方法

- 在 **定义属性或方法时**，在 **属性名或者方法名前** 增加 **两个下划线**，定义的就是 **私有** 属性或方法

```python
class Women:

    def __init__(self, name):

        self.name = name
        # 不要问女生的年龄
        self.__age = 18

    def __secret(self):
        print("我的年龄是 %d" % self.__age)


xiaofang = Women("小芳")
# 私有属性，外部不能直接访问
# print(xiaofang.__age)

# 私有方法，外部不能直接调用
# xiaofang.__secret()

```

- **访问对象的 私有属性 或 私有方法**(不推荐)

```python
# 私有属性，外部不能直接访问到
print(xiaofang._Women__age)

# 私有方法，外部不能直接调用
xiaofang._Women__secret()

```

### 8. 继承

#### 8.1 单继承

1. ##### 继承的传递性

- `C` 类从 `B` 类继承，`B` 类又从 `A` 类继承
- 那么 `C` 类就具有 `B` 类和 `A` 类的所有属性和方法

2. ##### 方法的重写

   1) 覆盖父类的方法

   - *具体的实现方式，就相当于在* **子类中** *定义了一个* **和父类同名的方法并且实现**

   - 重写之后，在运行时，**只会调用** 子类中重写的方法，而不再会调用 **父类封装的方法**

     

3. ##### 对父类方法进行 **扩展**

- 如果在开发中，子类的方法实现中包含父类的方法实现
  - **父类原本封装的方法实现** 是 **子类方法的一部分**
- 就可以使用扩展的方式
  1. **在子类中** **重写** 父类的方法
  2. 在需要的位置使用 `super().父类方法` 来调用父类方法的执行
  3. 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

4. ##### 父类的 私有属性 和 私有方法

   1. **子类对象** **不能** 在自己的方法内部，**直接** 访问 父类的 **私有属性** 或 **私有方法**
   2. **子类对象** 可以通过 **父类** 的 **公有方法** **间接** 访问到 **私有属性** 或 **私有方法**

   > - **私有属性、方法** 是对象的隐私，不对外公开，**外界** 以及 **子类** 都不能直接访问
   > - **私有属性、方法** 通常用于做一些内部的事情





#### 8.2 多继承

##### 1 多继承的使用注意事项

- 如果 **不同的父类** 中存在 **同名的方法**，**子类对象** 在调用方法时，会调用 **哪一个父类中**的方法呢？

  > *提示：***开发时，应该尽量避免这种容易产生混淆的情况！** *—— 如果* **父类之间** *存在* **同名的属性或者方法***，应该* **尽量避免** *使用多继承*

###### Python 中的 MRO —— 方法搜索顺序（知道）

- `Python` 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看 **方法** 搜索顺序
- MRO 是 `method resolution order`，主要用于 **在多继承时判断 方法、属性 的调用 路径**

```python
print(C.__mro__)
```

###### **输出结果**

```python
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

- 在搜索方法时，是按照 `__mro__` 的输出结果 **从左至右** 的顺序查找的
- 如果在当前类中 **找到方法，就直接执行，不再搜索**
- 如果 **没有找到，就查找下一个类** 中是否有对应的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序报错

### 9 新式类与旧式（经典）类

> `object` 是 `Python` 为所有对象提供的 **基类**，提供有一些内置的属性和方法，可以使用 `dir` 函数查看

- **新式类**：以 `object` 为基类的类，**推荐使用**
- **经典类**：不以 `object` 为基类的类，**不推荐使用**
- 在 `Python 3.x` 中定义类时，如果没有指定父类，会 **默认使用** `object` 作为该类的 **基类** —— `Python 3.x` 中定义的类都是 **新式类**
- 在 `Python 2.x` 中定义类时，如果没有指定父类，则不会以 `object` 作为 **基类**

> **新式类** 和 **经典类** 在多继承时 —— **会影响到方法的搜索顺序**

为了保证编写的代码能够同时在 `Python 2.x` 和 `Python 3.x` 运行！
今后在定义类时，**如果没有父类，建议统一继承自 `object`**

```python
class 类名(object):
    pass
```

#### 10 多态

- `Person` 类中只需要让 **狗对象** 调用 `game` 方法，而不关心具体是 **什么狗**
- 在程序执行时，传入不同的 **狗对象** 实参，就会产生不同的执行效果

> **多态** *更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！*

```python
class Dog(object):

    def __init__(self, name):
        self.name = name

    def game(self):
        print("%s 蹦蹦跳跳的玩耍..." % self.name)


class XiaoTianDog(Dog):

    def game(self):
        print("%s 飞到天上去玩耍..." % self.name)


class Person(object):

    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):

        print("%s 和 %s 快乐的玩耍..." % (self.name, dog.name))

        # 让狗玩耍
        dog.game()


# 1. 创建一个狗对象
# wangcai = Dog("旺财")
wangcai = XiaoTianDog("飞天旺财")

# 2. 创建一个小明对象
xiaoming = Person("小明")

# 3. 让小明调用和狗玩的方法
xiaoming.game_with_dog(wangcai)
        
```

